# Регулярные выражения в Python

**источники:**  
[python.org](https://docs.python.org/3.8/library/re.html)    
[tproger.ru](https://tproger.ru/translations/regular-expression-python/)   
[wikipedia.org](https://ru.wikipedia.org/wiki/%D0%A0%D0%B5%D0%B3%D1%83%D0%BB%D1%8F%D1%80%D0%BD%D1%8B%D0%B5_%D0%B2%D1%8B%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F)

**Регулярные выражения** (их еще называют regexp, или regex) — это механизм для поиска и замены текста.  
Для чего используются регулярные выражения:
- для определения нужного формата, например телефонного номера или email-адреса;
- для разбивки строк на подстроки;
- для поиска, замены и извлечения символов;
- для быстрого выполнения нетривиальных операций.
- Удалить все файлы, начинающиеся на test (чистим за собой тестовые данные)
- Найти все логи
- Найти все нужные файлы в папке.
- Grep-нуть логи — отсечь все лишнее и найти только ту информацию, которая нужна.
- Проверить по базе, нет ли явно некорректных записей — не остались ли тестовые данные в продакшене.
- Выверить файлик текстов для сайта — нет ли там дублирования слов

Регулярные выражения можно практиковать на:
- [regex101](https://regex101.com/)
- [myregexp.com](http://myregexp.com/)
- [regexr.com](https://regexr.com/)

## Основы по написанию регулярных выражений
источник: [habr.com](https://habr.com/ru/post/545150/)
### Поиск одного символа
Символ точка найдет любой один символ, включая цифры, спецсимволы и пробелы.
```
Текст:  Аня, Таня, А&я, Валя, Оля, Аля, А6я, А я
Regex: A.я
Резульат: Аня, А&я, Аля, А6я, А я
```
Если необходимо найти точку в тексте, то необходимо экранировать <code>Regex: \.txt </code>, т.е.
- `.` — любой символ
- `\.` — точка

### Поиск по набору символов
Применяется диапазон допустимых значений c помощью квадратных скобок.
```
Текст: Анна, Алла, аоикА74арплт, Аркан, А^&а, Абба
Regex: А[нл][нл]а
Резульат: Анна, Алла
```
Внутри скобок может быть перечисление необходимых букв или диапазон.
```
[нл] — только «н» и «л»
[а-я] — все русские буквы в нижнем регистре от «а» до «я» (кроме «ё»)
[А-Я]    — все заглавные русские буквы
[А-Яа-яЁё]  — все русские буквы
[a-z]  — латиница мелким шрифтом
[a-zA-Z]  — все английские буквы
[0-9]  — любая цифра
[В-Ю]   — буквы от «В» до «Ю» (да, диапазон — это не только от А до Я)
[А-ГО-Р]   — буквы от «А» до «Г» и от «О» до «Р»
```
Перечисление допустимых символов идет без разделителей <code>[абв] — только «а», «б» или «в»</code>.  
Единственный допустимый разделитель — это дефис. Если система видит дефис внутри квадратных скобок — значит, это диапазон.
- Символ до дефиса — начало диапазона
- Символ после — конец
 
<code> [1-31]</code> - диапазон от 1 до 3 и число 1
    
_^ внутри [] означает исключение:_
```
[^0-9]  — любой символ, кроме цифр
[^ёЁ]  — любой символ, кроме буквы «ё»
[^а-в8]  — любой символ, кроме букв «а», «б», «в» и цифры 8
```
```
Текст: file.txt, log.txt, file_1.txt, 1.txt
Regex: [^0-9]\.txt
Резульат: file.txt, log.txt
```
Так как квадратные скобки являются спецсимволами, то их нельзя найти в тексте без экранирования:
```
Regex: fruits\[0\]
Найдет: fruits[0]
Не найдет: fruits0

Regex: fruits\[[0-9]\]
Найдет: fruits[0] = “апельсин”; fruits[1] = “яблоко”; fruits[2] = “лимон”;
Не найдет: cat[0] = “чеширский кот”;
```
### Перечисление вариантов 
Квадратные скобки [] помогают перечислить варианты для одного символа. Если же необходимо перечислить слова, то лучше использовать вертикальную черту — |.
```
Regex: Оля|Олечка|Котик
Найдет: Оля, Олечка, Котик
Не найдет: Оленька, Котенка
```
Круглые скобки обозначают группу символов.
```
Regex: А(н|л)я
Найдет: Аня, Аля
```
Круглые скобки необходимы для того что бы показать где начинается и заканчивается группа.
```
Regex: Ан|ля

Найдет: Аня, Аля, Оля, Малюля
```
Эти 2 варианта вернут одно и то же:  
- А(н|л)я
- А[нл]я 

Но для замены одной буквы лучше использовать [], так как сравнение с символьным классом выполняется проще, чем обработка группы с проверкой на все её возможные модификаторы.

### Метасимволы
В регулярных выражениях используются специальные метасимволы, которые заменяют собой конкретный диапазон значений:
```
Символ ---> Эквивалент -------> Пояснение  
\d -------> [0-9] ------------> Цифровой символ  
\D -------> [^0-9] -----------> Нецифровой символ  
\s -------> [ \f\n\r\t\v] ----> Пробельный символ  
\S -------> [^ \f\n\r\t\v] ---> Непробельный символ  
\w -------> [[:word:]] -------> Буквенный или цифровой символ или знак подчёркивания  
\W -------> [^[:word:]] ------> Любой символ, кроме буквенного или цифрового символа или знака подчёркивания  
. ----------------------------> Вообще любой символ  
 ```
В пробельные символы входит:
 ```
Символ ----> Пояснение
  ----------> Пробел
\r --------> Возврат каретки (Carriage return, CR)
\n --------> Перевод строки (Line feed, LF)
\t --------> Табуляция (Tab)
\v --------> Вертикальная табуляция (vertical tab)
\f --------> Конец страницы (Form feed)
[\b] ------> Возврат на 1 символ (Backspace)
 ```
Cимвол `backspace` — это ASCII символ, который может появляться в тексте (ASCII code 8, или 10 в octal). Вы можете «создать» его, написать в консоли браузера (там используется JavaScript)

`[[:word:]]` - это один из способов заменить диапазон. Чтобы запомнить проще было, написали значения на английском, объединив символы в классы.
 ```
Класс символов -----> Пояснение
[[:alnum:]] --------> Буквы или цифры: [а-яА-ЯёЁa-zA-Z0-9]
[[:alpha:]] --------> Только буквы: [а-яА-ЯёЁa-zA-Z]
[[:digit:]] --------> Только цифры: [0-9]
[[:graph:]] --------> 	
Только отображаемые символы (пробелы, служебные знаки и т. д. не учитываются)
[[:print:]] --------> Отображаемые символы и пробелы
[[:space:]] --------> Пробельные символы [ \f\n\r\t\v]
[[:punct:]] --------> Знаки пунктуации: ! " # $ % & ' ( ) * + , \ -. / : ; < = > ? @ [ ] ^ _ ` { | }
[[:word:]] ---------> Буквенный или цифровой символ или знак подчёркивания: [а-яА-ЯёЁa-zA-Z0-9_]
```
### Спецсимволы
Большинство символов в регулярном выражении представляют сами себя за исключением специальных символов: `[ ] \ / ^ $ . | ? * + ( ) { }`

### Квантификаторы (количество повторений)
Символ «+» означает «одно или более повторений».
 ```
Regex: \w+@\w+\.\w+
Найдет: test@mail.ru, olga31@gmail.com
 ```
**Квантификаторы:**
```
Квантификатор ---> Число повторений
? ---------------> Ноль или одно
* ---------------> Ноль или более
+ ---------------> Один или более
```
Символ * часто используют с точкой — когда нам неважно, какой идет текст до интересующей нас фразы, мы заменяем его на «.*» — любой символ ноль или более раз.
```
Regex: .*\d\d\.\d\d\.\d\d\d\d.*
Найдет: 01.01.2000; Приходи на ДР 09.08.2015! Будет весело!

Regex: log\d*\.txt
Найдет: log.txt; log1.txt; log2.txt; log3.txt; log33.txt; log133.txt;

Regex: Назина?
Найдет: Назин; Назина
```
**Квантификаторы:**
```
Квантификатор ---> Число повторений
{n} -------------> Ровно n раз
{m,n} -----------> От m до n включительно
{m,} ------------> Не менее m
{,n} ------------> Не более n
```
Квантификатор применяется к последнему символу или группе символов!
```
Regex: data{2}
Найдет: dataa
Не найдет: datadata

Regex: (data){2}
Найдет: datadata
Не найдет: dataa
```
### Ленивый или жадный квантификатор 
```
Жадный -----> Ленивый
* ----------> *?
+ ----------> +?
{n,} -------> {n,}?
```
В разных реализациях регулярные выражения могут работать немного по разному. Это одно из отличий — в некоторых реализациях квантификаторам соответствует максимально длинная строка из возможных. Такие квантификаторы называют жадными.  
Определить квантификатор как нежадный (ленивый, англ. lazy) — большинство реализаций позволяют это сделать, добавив после него знак вопроса.  
Использование ленивых квантификаторов может повлечь за собой обратную проблему — когда выражению соответствует слишком короткая, в частности, пустая строка.

### Метасимволы, обозначающие позицию строки
```
Символ ----> Значение
\b --------> граница слова
\B --------> не граница слова
^ ---------> начало текста (строки)
$ ---------> конец текста (строки)
```
`\b` - означает границу слова  
```
Regex: \bарка\b
Найдет: арка
Не найдет: чарка аркан баварка знахарка
```
метасимвол \B, он найдет НЕ-границу слова:
```
Regex: \Bакр\B
Найдет: закройка
Не найдет: акр акрил
```
если необходимо найти конкретную фразу:
- `^` — начало текста (строки)
- `$` — конец текста (строки)
```
Regex: ^Я нашел!$
Найдет: Я нашел!
Не найдет: Смотри! Я нашел!; Я нашел! Посмотри!
```
### Использование ссылки назад
```
Допустим, при тестировании приложения вы обнаружили забавный баг в тексте — дублирование предлога «на». А потом решили проверить, есть ли в коде еще такие ошибки.

Regex: [ ]+(\w+)[ ]+\1
Текст: Поздравляем! Вы прошли на на новый уровень. Так что что улыбаемся и и машем.

[ ]+ → один или несколько пробелов, так мы ограничиваем слово. В принципе, тут можно заменить на метасимвол \b.
(\w+) → любой буквенный или цифровой символ, или знак подчеркивания. Квантификатор «+» означает, что символ должен идти минимум один раз. А то, что мы взяли все это выражение в круглые скобки, говорит о том, что это группа. Зачем она нужна, мы пока не знаем, ведь рядом с ней нет квантификатора. Значит, не для повторения. Но в любом случае, найденный символ или слово — это группа 1.
[ ]+ → снова один или несколько пробелов.
\1 → повторение группы 1. Это и есть ссылка назад. Так она записывается в JavaScript-е.
```
Синтаксис ссылок назад очень зависит от реализации регулярных выражений.  
Пример применения ссылки назад: можно проверить верстку HTML, правильно ли ее составили - верно ли, что открывающийся тег равен закрывающемуся?
### Просмотр вперед и назад
```
Представление -----> Вид просмотра
(?=шаблон) --------> Позитивный просмотр вперёд
(?!шаблон) --------> Негативный просмотр вперёд (с отрицанием)
(?<=шаблон) -------> Позитивный просмотр назад
(?шаблон) ---------> Негативный просмотр назад (с отрицанием)
```
Пример (?=шаблон):
```
Regex: Блюдо(?=11)
найдет: Блюдо11 Блюдо113 
Не найдет: Блюдо1 Блюдо511
```
Пример (?!шаблон):
```
Regex: Блюдо(?!11)
найдет: Блюдо1 Блюдо511
ненайдет: Блюдо11 Блюдо113
```
Пример (?<=шаблон):
```
Regex: (?<=Ольга )Назина
найдет: Ольга Назина
ненайдет: Анна Назина
```
Пример (?шаблон):
```
Regex: (?<!Ольга )Назина
найдет: Анна Назина
ненайдет: Ольга Назина
```
### Замена
Находит текст и заменяет его на другой текст.  
Знак доллара в замене — обращение к группе в поиске. Поставить знак доллара и номер группы. Группа — это то, что в круглых скобки. Нумерация у групп начинается с 1.
```
RegEx: (Оля) \+ Маша
Замена: $1
Текст был: Привет, Оля + Маша!
Текст стал: Привет, Оля!
```
Можно каждую часть текста взять в круглые скобки, а потом варьировать и менять местами:
```
RegEx: (Оля) \+ (Маша)
Замена: $2 - $1
Текст был: Оля + Маша
Текст стал: Маша — Оля
```



## Модуль Re 
Для работы с регулярными выражениями необходимо вызвать модуль re.
```python
import re
```
Популярные методы из модуля:
- <code>match()</code> - ищет последовательность в начале строки
- <code>search()</code> - ищет первое совпадение с шаблоном
- <code>findall()</code> - ищет все совпадения с шаблоном. Возвращает результирующие строки в виде списка
- <code>split()</code> - для разделения строки на части
- <code>sub()</code> - для замены в строках
- <code>compile()</code> - компилирует регулярное выражение. К этому объекту затем можно применять все перечисленные функции
- <code>fullmatch()</code> - - вся строка должна соответствовать описанному регулярному выражению


